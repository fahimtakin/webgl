<html>
  <!-- This is a simple demo of WebGL that Draws a Triangle-->
  <head>
    <meta charset="UTF-8" />
    <title>Assignment</title>

    <!-- Vertex Shader-->
    <script id="vertexShader" type="x-shader/x-vertex">
      attribute vec3 a_coords; //position attributeCoords
      attribute vec3 a_color;  //color attribute
      varying vec3 vcolor;
      void main(){
          gl_Position = vec4(a_coords, 1);
          vcolor = a_color;
      }
    </script>

    <!--Fragment Shader-->
    <script id="fragmentShader" type="x-shader/x-fragment">
      precision mediump float;
      varying vec3 vcolor;
      void main(){
          gl_FragColor = vec4(vcolor,1);
      }
    </script>

    <script type="text/javascript">
      "use strict";
      var gl; //the WebGL graphics context
      var prog; //the shader program

      var attributeCoordsLoc; //location of the attribute named "a_coords"
      var bufferCoords; // vertex buffer object (VBO) holding the values of coords

      var attributeColorLoc; //Location of the attribute name "a_color"
      var bufferColor; //vertex buffer object VBO holding values for color

      /*  Draws the content of the canvas, in this case, the RGB color triangle.*/
      function draw() {
        gl.clearColor(0, 0, 0, 1); // specify the color to be used for clearing
        gl.clear(gl.COLOR_BUFFER_BIT); // clear the canvas (to black)

        /*associate variables in shader program*/
        gl.useProgram(prog);
        attributeCoordsLoc = gl.getAttribLocation(prog, "a_coords");
        bufferCoords = gl.createBuffer();
        attributeColorLoc = gl.getAttribLocation(prog, "a_color");
        bufferColor = gl.createBuffer();

        /* Set up values for the "a_coords" attribute */
        var coords = new Float32Array([
          -0.2, 0, 0, 0.2, 0, 0, 0, 0.2, 0, -0.2, -0.2, 0, 0.2, -0.2, 0, 0.2, 0,
          0, -0.2, 0, 0,
        ]);

        gl.bindBuffer(gl.ARRAY_BUFFER, bufferCoords);
        gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STREAM_DRAW);
        gl.vertexAttribPointer(attributeCoordsLoc, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(attributeCoordsLoc);

        /* Set up values for the "a_color" attribute */
        var color = new Float32Array([
          124, 252, 0, 124, 252, 0, 124, 252, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
          1, 1,
        ]);
        gl.bindBuffer(gl.ARRAY_BUFFER, bufferColor);
        gl.bufferData(gl.ARRAY_BUFFER, color, gl.STATIC_DRAW);
        gl.vertexAttribPointer(attributeColorLoc, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(attributeColorLoc);

        /* Draw the triangle. */
        gl.drawArrays(gl.TRIANGLE_FAN, 0, 3);
        gl.drawArrays(gl.TRIANGLE_FAN, 3, 4);
      }

      /* Creates a program for use in the WebGL context gl, and returns the
            identifier for that program. */
      function createProgram(gl, vertexShaderSource, fragmentShaderSource) {
        let vsh = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vsh, vertexShaderSource);
        gl.compileShader(vsh);
        if (!gl.getShaderParameter(vsh, gl.COMPILE_STATUS)) {
          throw new Error(
            "Error in vertex shader:  " + gl.getShaderInfoLog(vsh)
          );
        }
        let fsh = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fsh, fragmentShaderSource);
        gl.compileShader(fsh);
        if (!gl.getShaderParameter(fsh, gl.COMPILE_STATUS)) {
          throw new Error(
            "Error in fragment shader:  " + gl.getShaderInfoLog(fsh)
          );
        }
        let prog = gl.createProgram();
        gl.attachShader(prog, vsh);
        gl.attachShader(prog, fsh);
        gl.linkProgram(prog);
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
          throw new Error(
            "Link error in program:  " + gl.getProgramInfoLog(prog)
          );
        }
        return prog;
      }

      /* Initialize the WebGL graphics context */
      function initGL() {
        const vertexShaderSource = document.getElementById("vertexShader").text;
        const fragmentShaderSource =
          document.getElementById("fragmentShader").text;
        prog = createProgram(gl, vertexShaderSource, fragmentShaderSource);
      }

      /** Initialize the program, the function is called after the page is loaded*/
      function init() {
        try {
          let canvas = document.getElementById("webglcanvas");
          let options = {
            // no need for alpha channel or depth buffer in this program
            alpha: false,
            depth: false,
          };
          gl = canvas.getContext("webgl", options);
          // (Note that this page could use "webgl2" with no further modification.)
          if (!gl) {
            throw "Browser does not support WebGL";
          }
        } catch (e) {
          document.getElementById("canvas-holder").innerHTML =
            "<p>Sorry, could not get a WebGL graphics context.</p>";
          return;
        }
        try {
          initGL(); // initialize the WebGL graphics context
        } catch (e) {
          document.getElementById("canvas-holder").innerHTML =
            "<p>Sorry, could not initialize the WebGL graphics context: " +
            e.message +
            "</p>";
          return;
        }
        draw(); // draw the image
      }

      window.onload = init; // Arrange for init() to be called when the page has been loaded.
    </script>
  </head>
  <body>
    <noscript>
      <p><b> Sorry, but this page requires JavaScript.</b></p></noscript
    >
    <div id="canvas-holder">
      <center>
        <canvas id="webglcanvas" width="800" height="800"> </canvas>
      </center>
    </div>
  </body>
</html>
